# PyLapi SDK Generator
#
# This script generates a PyLapi SDK from a configuration file.
#
# Steps:
# 1. Create a configuration file (from the configuration template python file) in the *same* directory as this script.
# 2. Customise the configuration file by following the insturctions in the comment.
# 3. Run this script with the configuration file as the first argument
#    - The OpenAPI specification JSON file is specified
#      - as the second argument, or if not specified
#      - in the configuration file `oas` variable, or if not specified
#      - as the configuration file name with .py replaced by .json
#    - The OpenAPI JSON file path is either absolute or relative to the current directory.

import json
import yaml
import re
import sys
import os


def dict_checked(dict_data, attr, default=""):
    return dict_data[attr] if attr in dict_data else default


def printl(line=""):
    print(line.rstrip())

# Load the config settings
main_basename = os.path.basename(sys.argv[0])

usage = f"Usage: {main_basename} <config.py> [<openapi.json/yaml]"

sys_argv = sys.argv[1:]

do_generate_sdk = True
if sys_argv[0] == "-d":
    do_generate_sdk = False
    del sys_argv[0]

if len(sys_argv) < 1 or len(sys_argv) > 2:
    print(f"{usage}")
    exit(1)

config_file = sys_argv[0]
del sys_argv[0]

config_module = re.sub(r"\.py$", "", os.path.basename(config_file))
import importlib
config = importlib.import_module(config_module)

oas = f"{config_module}.json"
if len(sys_argv) == 1:
    # openapi.json specified
    oas = sys_argv[0]
else:
    try:
        oas = config.oas
    except:
        pass

oas_type = re.sub(r".+\.(json|yaml)$", "\\1", oas)
# print(f"oas={oas} ({oas_type})")

try:
    if oas_type == "json":
        oas_doc = json.load(open(oas, "r"))
    elif oas_type == "yaml":
        oas_doc = yaml.safe_load(open(oas, "r"))
    else:
        raise Exception(f"Unknown file type: {oas}")
except:
    raise Exception(f"{oas} cannot be opened")

try:
    oas_server_url = oas_doc["servers"][0]["url"]
except:
    raise Exception(f"OAS Error: No server urls found")

try:
    oas_methods = oas_doc["paths"]
except:
    raise Exception(f"OAS Error: No paths found")

methods = []
for oas_path in oas_methods:
    # print(f"oas_path={oas_path}")
    oas_http_methods = oas_methods[oas_path]
    # print(f"oas_http_methods={oas_http_methods}")
    if "parameters" in oas_http_methods:
        # oas_parameters = oas_http_methods["parameters"]
        del oas_http_methods["parameters"]
    for oas_http_method in oas_http_methods:
        oas_method = oas_http_methods[oas_http_method]
        if "operationId" not in oas_method:
            raise Exception(f"operationId missing in {oas_path}:{oas_http_method}")
        # print(f"{oas_path}/{oas_http_method}")
        # Existance of each attribute is guaranteed
        method_to_add = config.Method({
            "path": oas_path.lstrip("/"),
            "http_method": oas_http_method,
            "operation_id": oas_method["operationId"],
            "summary": dict_checked(oas_method, "summary"),
            "description": dict_checked(oas_method, "description"),
            "parameters": [] if "parameters" not in oas_method else [
                {
                    _["name"]: {
                        "in": dict_checked(_, "in"),
                        "description": dict_checked(_, "description"),
                        "required": dict_checked(_, "required", False),
                    } for _ in oas_method["parameters"] if "name" in _
                }
            ]
        })

        # print(method_to_add)
        methods.append(method_to_add)

methods.sort(key=lambda _: f"{_.class_name}/{_.method_name}")
# for method in methods:
#     print(f"path={method.path}")
#     print(json.dumps(method._method, indent=2))

class_set = sorted(set(_.class_name for _ in methods))
classes = {}
for class_name in class_set:
    methods_of_class = [_.method_name for _ in methods if _.class_name == class_name]
    classes.update({
        class_name: {
            "methods": methods_of_class,
            "count": len(methods_of_class),
        }
    })
# classes = {
#     _: len([__.method_name for __ in methods if __.class_name == _])
#     for _ in class_set
# }

printl(f"# PyLapi SDK generated by {main_basename}")
printl(f"#")
printl(f"# SDK Class: {config.sdk_class_name}")
printl(f"# {len(classes)} Resource Classes (number of methods):")
for _ in classes:
    printl(f"#      {_} ({classes[_]['count']})")
printl(f"# Total: {len(methods)} methods")

if not do_generate_sdk:
    # Output OAS analysis then exit
    printl(f"#")
    ii = 0
    for method in methods:
        ii += 1
        printl(f"#{ii:4}. {method.class_name}:{method.method_name}(): {method.http_method} {method.path}")
    exit(0)

# SDK Class
printl("""
from pylapi import PyLapi

class """+config.sdk_class_name+"""(PyLapi):
    def __init__(self, *args, **kwargs) -> None:
        super().__init__(*args, **kwargs)
        self.api_url = \""""+oas_server_url+"""\"
        self.api_auth_type = \""""+config.api_auth_type+"""\"

        # Custom __init__ statements""")
try:
    for init_line in config.sdk_class_init.split("\n"):
        printl(f"        {init_line}")
except:
    pass
printl()

printl(f"    # Custom {config.sdk_class_name} methods")
try:
    for sdk_method in config.sdk_methods.split("\n"):
        printl(f"    {sdk_method}")
except:
    pass
printl()

resource_method_args_str = ""
try:
    for resource_method_arg in config.resource_method_args:
        val = config.resource_method_args[resource_method_arg]
        if type(val) == str:
            val = f'"{val}"'
        resource_method_args_str += f", {resource_method_arg}={val}"
except:
    pass

# `resource_class` - change of first path item
# `resource_method` - on every path, method being operation_id
last_class_name = None
num_methods = 0
for method in methods:
    this_class_name = method.class_name
    if this_class_name != last_class_name:
        if last_class_name != None and num_methods == 0:
            printl("    pass")
            printl()
        last_class_name = this_class_name
        num_methods = 0
        printl()
        printl(f"@{config.sdk_class_name}.resource_class(\"{method.resource_name}\", \"{method.class_path}\")")
        printl(f"class {method.class_name}({config.sdk_class_name}):")
        # printl()
        printl(f"# To instantiate: {config.sdk_class_name}.resource(\"{method.resource_name}\")")
        printl(f"# Number of methods: {classes[method.class_name]['count']}")
        for _ in classes[method.class_name]["methods"]:
            printl(f"#     {_}")

    num_methods += 1

    printl()
    printl(f"    @{config.sdk_class_name}.resource_method(\"{method.resource_path}\", http_method=\"{method.http_method}\"{resource_method_args_str})")
    printl(f"    def {method.method_name}(self): pass")
    # printl()
    printl(f"    # To call: {config.sdk_class_name}.resource(\"{method.resource_name}\").{method.method_name}(...)")
    printl(f"    # {method.http_method} {oas_server_url}{method.api_path}")

    try:
        summary = method.summary
        summary = re.sub(r"\n", "\n    #   ", summary)
        summary = re.sub(r" +\n", "\n", summary)
    except:
        pass
    else:
        if summary:
            printl(f"    # Summary: {summary}")

    try:
        description = method.description
        description = re.sub(r"\n", "\n    #   ", description)
        description = re.sub(r" +\n", "\n", description)
    except:
        pass
    else:
        if description:
            printl(f"    # Description: {description}")

    try:
        parameters = re.sub(r"\n", "\n    #   ", re.sub(r"^-", "   ", yaml.dump(method.parameters, indent=2)))
    except:
        pass
    else:
        if len(method.parameters) > 0 and method.parameters != [{}]:
            printl(f"    #")
            printl(f"    # Parameters:")
            printl(f"    # {parameters}")

    printl()

if last_class_name and num_methods == 0:
    printl("    pass")
